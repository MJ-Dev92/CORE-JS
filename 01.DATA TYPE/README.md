# 1장 데이터 타입

## 1. 데이터 타입의 종류

- 자바스크립트의 데이터 타입에는 기본형과 참조형으로 크게 두가지가 있다.
- 기본형에는 숫자, 문자열, 불리언, null, undefined, 심볼이 있다.
- 참조형은 객체가 있고, 배열, 함수, 날짜, 정규표현식등이 있다.

### 1.1.1 기본형과 참조형 구분 기준

- 일반적으로 기본형은 할당이나 연산시 복제되고 참조형은 참조된다.
- 기본형은 값이 담긴 주솟값을 바로 복제하고 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다.
- 기본형은 불벼성을 띈다.

## 2. 데이터 타입에 관한 배경지식

### 1.2.1 메모리와 데이터

- 각 비트는 고유한 식별자를 지닌다. 바이트 역시 시작하는 비트의 식별자로 위치를 파악할 수 있다. 모든 데이터는 바이트 단위의 식별자, 더 정확하게는 **메모리 주솟값**을 통해 서로 구분하고 연결할 수 있다.

### 1.2.2 식별자와 변수

- **변수**는 ‘변할 수 있는 수’이다. 컴퓨터 용어로는 ‘**변할 수 있는 무언가**’라고 정의한다. 여기서 ‘무언가’란 **데이터**를 말한다.
- **식별자**는 어떤 데이터를 식별하는 데 사용하는 이름, 즉 **변수명**이다.

## 3. 변수 선언과 데이터 할당

### 1.3.1 변수 선언

```jsx
var a;
```

- 위 예제를 말로 풀어쓰면 “**변할 수 있는 데이터를 반든다. 이 데이터의 식별자는 a로 한다.**”
- 변수란 **변경 가능한 데이터가 담길 수 있는 공간 또는 그릇**이라고 생각하면 된다.

### 1.3.2 데이터 할당

```jsx
var a; // 변수 a 선언
a = "abc"; // 변수 a에 데이터 할당

var a = "abc"; // 변수 선언과 할당을 한 문장으로 표현
```

- 식별자 주소를 검색해 문자열을 할당할거 같지만 데이터를 저장하기 위해 별도의 메모리 공간을 다시 확보해서 문자열 ’abc’를 저장하고 그 주소를 변수 영역에 저장하는 식으로 이루어진다.
- 컴퓨터가 처리해야 할 연산이 많아질 수밖에 없기 때문에 효율적으로 관리하기 위해서는 각각 별도의 공간으로 나누어 저장하는 것이 최적이다. 즉 변수 영역과 데이터 영역이 나누어져있다.
- 만약 ‘abcdef’를 추가한다면 기존의 데이터영역 ‘abc’ 뒤에 ‘def’가 추가되는 것이 아니라 새로 만들어 별도의 공간에 저장하고 그 주소를 변수 공간에 연결한다.
- 매번 같은 숫자를 새로 만들 필요가 없어지므로 이처럼 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아진다.

## 4. 기본형 데이터와 참조형 데이터

### 1.4.1 불변값

- 변수와 상수를 구분하는 성질은 ‘변경 가능성’이다. 변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역** 메모리이다.
- 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건이다.
- 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역** 메모리이다

```jsx
var b = 5;
var c = 5;
b = 7;
```

- 불변값과 상수를 같은 개념으로 오해하기 쉬운데 이 둘을 명확히 구분할 필요가 있다.
- 위 예제 b의 값을 7로 바꾸려고 한다. 그려면 기존에 저장된 5 자체를 7로 바꾸는 것이 아니라 기존 저장했던 7을 찾아서 있으면 재활용하고, 없으면 새로 만들어 b에 저장한다 결국 5와 7 모두 다른 값으로 변경할 수 없다.
- 변경은 새로 만드는 동작을 통해서만 이뤄진다. 이것이 바로 불변값의 성질이고 한 번 만들어진 값은 가비지 컬렉티을 당하지 않는 한 영원히 변하지 않는다.

### 1.4.2 가변값

- 기본형 데이터는 모두 불변값이다. 그렇다면 참조형 데이터는 모두 가변값일것 같은 느낌이 든다. 우선 참조형 데이터를 변수에 할당하는 과정부터 확인해보자.

```jsx
var obj1 = {
  a: 1,
  b: "bbb",
};
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b8b7de6f-1c56-418f-9d2b-0df55f08f000/Untitled.png)

- 기본형 데이터와의 차이는 ‘객체의 변수(프로퍼티) 영역’이 별도로 존재한다는 점이다.
- 객체가 별도로 할애한 영역은 변수영역일 뿐 ‘데이터 영역’은 기존의 메모리 공간을 그대로 활용하고 있다. 데이터 영역에 저장된 값은 모두 불변값이다.
- 그러나 변수에는 다른 값을 얼마든지 대입할 수 있다. 이부분이 참조형 데이터는 불변한지 않다(가변값이다)라고 하는 이유이다.

```jsx
var obj1 = {
  a: 1,
  b: "bbb",
};
obj1.a = 2;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8859e652-3248-4fa9-bfee-0f7307945cf1/Untitled.png)

- 변수 obj1이 바라보고 있는 주소는 @5001로 변하지 않는다. 즉 ‘새로운 객체’가 만들어진 것이 아니라 기존의 객체 내부의 값만 바뀐다.
- 자신의 주소를 참조하는 변수의 개수를 참조 카운트라고 하는데 참조 카운트가 0이면 가비지 컬렉터의 수거 대상이 된다. 가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 떄마다 자동으로 수거 대상들을 수거한다.

### 1.4.3 변수 복사 비교

- 기본형 데이터와 참조형 데이터의 차이를 확인해보자

```jsx
var a = 10;
var b = a;

var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;
```

- 기본적으로 변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는점에서 동일하다. 복사과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 떄문에 변수 복사 이후의 동작에도 큰 차이가 발생한다.

```jsx
var a = 10;
var b = a;

var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

- b의 값 15가 없으므로 새로운 공간에 저장하고 그 주소를 든 채로 변수 영역에서 실별자 주소를 찾아 새로운 공간 주소로 대입한다.
- obj2.c의 값은 데이터 영역에서 20이 없으므로 새로운 공간에 저장하고 그 주소를 든 채로 변수 영역에서 c를 찾아 그곳에 새로운 공간 주소를 대입한다.
- 기본형 데이터를 복사한 변수 b의 값을 바꿨더니 변수 영역 값이 달라진 반면 참조형 데이터는 값을 바꾸었더니 변수 영역 값이 바뀌지 않았다.
- 즉 변수 a,b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1, obj2는 여전히 같은 객체를 바라보고 있는 상태이다

```jsx
a !== b;
obj1 === obj2;
```

- 이 결과가 바로 기본형과 참조형 데이터의 가장 큰 차이점이다. 어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값을 복사해야 하기 떄문에 엄밀히 따지면 모든 데이터 타입은 참조형 데이터일 수밖에 ㅇ벗다.
- 다만 기본형 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있다.

```jsx
// 객체 자체를 변경했을 때
var a = 10;
var b = a;

var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

b = 15;
obj2 = { c: 20, d: "ddd" };
```

- 메모리 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 위치에 저장한다. 객체에 대한 변경임에도 값이 달라진다.
- 즉 참조형 데이터가 ‘가변값’이라고 설명할 때의 ‘가변’은 참조형 데이터 자치를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다.

## 5. 불변 객체

### 1.5.1 불변 객체를 만드는 간단한 방법

- 참조형 데이터의 ‘가변’은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립한다. 데이터 자체를 변경하고자 하면 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않습니다.
- 그렇다면 내부 프로퍼티를 변경할 필요가 있을 때마다 새로운 객체를 만들어 재할당 규칙을 정하거나 자동으로 새로운 객체를 만드는 도구를 활용한다면 객체 역시 불변성을 확보할 수 있다.

```jsx
var user = {
  name: "Jaenam",
  gender: "male",
};

var changeName = function (user, newName) {
  return {
    name: newName,
    gender: user.gender,
  };
};

var user2 = changeName(user, "Jung");

if (user !== user2) {
  console.log("유저 정보가 변경되었습니다"); // 유저 정보가 변경되었습니다.
}

console.log(user.name, user2.name); // Jaenam Jung
console.log(user === user2); // false
```

- user와 user2는 서로 다른 객체리므로 안전하게 변경 전과 변경 후를 비교할 수 있다. 하지만 changeName 함수는 개로운 객체를 만들면서 변경할 필요가 없는 기존 객체의 프로퍼티를 하드코딩으로 입력했다.
- 이런 방식보다는 대상 객체의 프로퍼티 개수에 상관 없이 모든 프로퍼티를 복사하는 함수를 만드는 편이 더 좋다.

```jsx
var copyObject = function (target) {
  var result = {};
  for (var prop in target) {
    result[prop] = target[prop];
  }
  return result;
};
```

- for in 문법을 이용해 result 객체에 target 객체의 프로퍼티들을 복사하는 함수 입니다.

```jsx
var user = {
  name: "Jaenam",
  gender: "male",
};

var user2 = copyObject(user);
user2.name = "Jung";

if (user !== user2) {
  console.log("유저 정보가 변경되었습니다."); // 유저 정보가 변경되었습니다.
}

console.log(user.name, user2.name); // Janam Jung
console.log(user === user2); // false
```

- 모든 유저가 copyObject 함수를 사용하기로 합의하고 그 규칙을 지킨다는 전제하에 user 객체가 곧 불변 객체라고 볼 수 있다. 하지만 그 규칙을 지킨긴 어렵다. 프로퍼티를 변경할 수 없게끔 시스템적으로 제약을 거는 편이 안전할 것이다.
- immutable.js, baobao.js 등의 라이브러리 자체에서 불변성을 지닌 별도의 데이터 타입과 그에 따른 메서드를 제공한다.
- 무엇보다 얕은 복사만 수행한다는 부분이 가장 아쉽다.

### 1.5.2 얕은 복사와 깊은 복사

- 얕은 복사는 바로 아래 단계의 값만 복사하고 깊은 복사는 내부의 모든 값을 하나하나 찾아서 전부 복사하는 방법이다. 이말은 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사한다는 의미이다.
- 즉 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키게 됩니다. 사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀐다.

```jsx
// 중첩된 객체에 대한 깊은 복사

var user2 = copyObject(user);
user2.urls = copyObject(user.urls);

user.urls.portfolio = "http://portfolio.com";
console.log(user.srls.portfolio === user2.urls.portfolio); // false

user2.urls.blog = "";
console.log(user.urls.blog === user2.urls.blog); // false
```

- 어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사허면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사 해야한다.
- 이 과정을 참조형 데이터가 있을 때마다 재귀적으로 수행해야만 비로소 깊은 복사가 되는 것이다.

## 6. undefined와 null

- 자바스크립트에는 ‘없음’을 나타내는 값이 두 가지가 있다. udefined와 null이다.

### undefined를 반환하는 경우 세가지

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return문이 없거나 호출되지 않는 함수의 실행 결과

- undefined는 그 자체로 값입니다. undefined가 비록 ‘비어있음’을 의미하긴 하지만 하나의 값으로 동작하기 때문에 프로퍼티나 배열 요소는 고유의 키값이 실존하게 되고 따라서 순회의 대상이 될 수 있다.
- 값으로써 어딘가에 할당된 undefined는 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없을을 나타낸다.
- 같은 의미를 가진 null이라는 값이 별도로 있는데 굳이 undefined를 써야 할 이유가 없다. ‘비어있음’을 명시적으로 나타내고 싶을 때는 undefined가 아닌 null을 쓰면 된다.
- null은 애초부터 이런 용도로 만든 데이터 타입이다. 이런 규칙을 따르는 한 undefined는 오직 ‘값을 대입 하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값’으로서만 존재할 수 있다.
