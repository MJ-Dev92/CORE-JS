# 2장 실행 컨텍스트

## 01 실행 컨택스트란?

- 실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체다.
- 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장한다.
- 자동으로 생성되는 전역공간과 악마로 취급받는 eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것뿐입니다.

```jsx
// ---(1)
var a = 1;
function outer() {
  function inner() {
    console.log(a); // undefined
    var a = 3;
  }
  inner(); // ---(2)
  console.log(a); // 1
}

outer(); // ---(3)
console.log(a); // 1
```

- 최상단 공간은 코드 내부에서 별도의 실행 명령이 없어도 브라우저에서 자동으로 실행하므로 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화된다.
- 콜 스택에는 전역 컨텍스트 관련된 코드들을 순차로 진행하다가 (3) outer함수를 호출하면 자바스크립트 엔진은 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성 후 콜 스택에 담습니다.
- outer 함수 내부의 코드들을 순차로 실행되고 (2)에서 inner 함수의 실행 컨텍스트가 콜 스택의 가장 위에 담기고 inner 함수 내부의 코드를 순서대로 진행 합니다.
- inner 함수 내부에서 a 변수에 값 3을 할당하고 inner함수가 실행이 종료되면서 콜 스택에서 제거됩니다.
- 아래 있던 outer 컨텍스트가 콜 스택의 맨 위에 존재하게 되므로 (2) 다음 줄부터 이어서 실행되고 a 변수의 값을 출력하고 나면 outer 함수의 실행이 종료되고 전역 컨텍스트만 남아있게 된다.
- 그 후 a 변수의 값을 출력하고 전역에는 더 이상 코드가 남지않아 전역 컨텍스트도 제거되고 콜 스텍에는 아무것도 남지 않아 종료된다.
- 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장한다. 여기에 담기는 정보는 다음과 같다.
  - VariableEnvironment: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경 사항은 반영되지 않음
  - LexicalEnvironment : 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨
  - thisBinding: this 식별자가 바라봐야 할 대상 객체

## 02 LexicalEnvironment

### 2.2.1 environmentRecord와 호이스팅

- environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다. 매개변수 식별자, 선언한 함수가 있을 경우 그함수 자체 var로 선언된 변수의 식별자 등이 식별자에 해당한다.
- 컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가면 순서대로 수집한다.
- 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태이다. 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있다.
- 자바스크립트 엔진은 식별자들을 최상단으로 끌어욜려놓은 다음 실제 코드를 실행한다라고 생각해도 코드를 이해하는데 문제가 없다.
- 이를 호이스팅이라고 한다. 자바스크립트 엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주한다.

### 함수 선언문과 함수 표현식

- 함수 선언문은 전체를 호이스팅한 반면 함수 표현식은 변수 선언부만 호이스팅을 한다.
- 함수를 다른 변수에 값으로써 할당한 것이 곧 함수 표현식이다.
- 전역 컨텍스트가 활성화될 때 전역공간에 선언된 함수들이 모두 가장 위로 끌어올려집니다. 동일한 변수명에 서로 다른 값을 할당할 경우 나중에 할당한 값이 먼저 할당한 값을 덮어씌웁니다.
- 따라서 코드를 실행하는 중에 실제로 호출되는 함수는 오직 마지막에 할당한 함수, 즉 맨 마지막에 선언된 함수뿐이다.
- 극단적인 예시이지만 원활한 협업을 위해서는 전역공간에 함수를 선언하거나 동명의 함수를 중복 선언하는 경우는 없어야 한다. 전역 공간에 동명의 함수가 여럿 존재하는 상황이라 하더라도 모든 함수가 함수 표현식으로 전의돼 있었다면 위와 같은 상황은 일어나지 않는다.

### 2.2.2 스코프, 스코프 체인, outerEnvironmentReference

<aside>
📌 스코프란 식별자에 대한 유효범위이다. 자바스크립트는 특이하게도 전역공간을 제외하면 **오직 함수에 의해서만** 스코프가 생성된다.

</aside>

- 이러한 식별자의 유효범의를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 한다.
- 이를 가능케 하는 것이 바로 LexicalEnvironment의 두 번째 수집 자료인 outerEnvironmentReference이다.

### 스코프 체인

- outerEnvironmentReference는 연결리스트 형태를 띱니다.
- 또한 outerEnvironmentReference는 오직 자신이 선언된 시점의 LexicalEnvironment만 참조하고 있으므로 가장 가까운 요소부터 차례대로만 접근할 수 있다.
- 이런 구조적 특성 덕분에 여러 스코프에서 동일한 식별자를 선언한 경우에는 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능**하게 된다.
- inner함수 내부에서 a변수를 선언했기 때문에 전역 공간에서 선언한 동일한 이름의 a변수에는 접근할 수 없는 셈이다. 이를 **변수 은닉화**라고 한다.

### this

- 실행 컨텍스트의 thisBinding에는 this로 지정된 객체가 저장됩니다. 실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체가 저장됩니다.
- 그밖에는 함수를 호출하는 방법에 따라 this에 저장되는 대상이 다릅니다.
